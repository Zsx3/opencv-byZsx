# -*- coding: utf-8 -*-
"""
Created on Sun May 26 21:02:12 2019

@author: dell
"""

#理解k近邻
# =============================================================================
# 原理：
# KNN可以说是最简单的监督学习分类器，就是找出数据在特征空间中的最近邻居
# 我们用这张图片介绍
# 图分为2组，蓝色方块和红色三角  每一组可称为一个类
# 我们可以把所有这些对象看出一个城镇中的房子，而所有房子分别属于蓝色和红色家族，而这个城镇就是所谓的特征空间
# (例如一个二维空间，每个数据有xy两个特征，如果每个数据有三个特征呢，我们就需要一个三维空间，N个特征就需要N维空间，这个
#  N维空间就是特征空间，上图可以认为是具有两个特征色的2D空间)
# 
# 现在城镇中来了一个新人，他的房子用绿色圆盘表示，我们要根据他房子的位置把他归类为蓝色家族或者红色家族，我们把这个过程称为分类
# 。如何做呢，就是Knn
# 
# 一个方法就是看他距离最近的家族是哪个，图像中可以看到是红色家族，所以它被分类为红色家族，这种方法被称为简单近邻，因为分类仅仅决定于它
# 最近的邻居
# 
# 但是这还有一个问题，红色三角可能是最近的，但如果他周围还有很多蓝色方块怎么办呢？此时蓝色方块对局部的影响应该是大于红色三角。所有仅仅检测
# 最近的一个邻居是不足的，所以我们检测k个最近邻居，谁在这k个邻居中占据多数，那新的成员就属于谁的那一类，如果k等于3，，上图中3个最近邻居有2红
# 1蓝，所以它还是属于红色家族，但是如果k=7，5蓝2红，它就会被分到蓝色家族，但如果K=4，2红2蓝，这就是一个死结，所以k最好取奇数，这种根据k个最近邻居
# 进行分类的方法被称为KNN
# 
# 在KNN中，我们考虑了k个最近邻居，但我们给了这些邻居相等的权值，这样公平吗，以k=4为例，我们说这是一个死结，但是两个红色三角比2个蓝色方块距离新成员更近
# 所以他更应该被分为红色家族，那数学该如何表示呢，我们要根据每个房子与新房子的距离分配不同权重，距离近就高权重，远就低权重，谁权重大就属于谁，这种被称为
#  修改过的KNN
#  
#  
# 我们将红色家族标记为class-0 蓝色家族标记为class-1  还要再创建25个训练数据，把他们分别标记为class-0 或class-1
# numpy产生随机数可以帮我们完成这个任务
# 
# 然后借助matplotlib 将这些点绘制出来，红色家族显示为红色三角 蓝色家族显示为蓝色方块
# =============================================================================


import cv2
import numpy as np
import matplotlib.pyplot as plt

trainData=np.random.randint(0,100,(25,2)).astype(np.float32)
responses=np.random.randint(0,2,(25,1)).astype(np.float32)

red=trainData[responses.ravel()==1]
plt.scatter(red[:,0],red[:,1],80,'r','^')

blue=trainData[responses.ravel()==0]
plt.scatter(blue[:,0],blue[:,1],80,'b','s')

# =============================================================================
# 你可能会得到上面类似的图形，但不会完全一样，因为你使用了随机数产生器，每次运行代码都会得到不同结果
# 下面就是KNN算法分类器的初始化，我们要传入一个训练数据集，以及与训练数据对应的分类来训练KNN分类器（构建搜索树）
# 
# 最后要使用opencv中的KNN的分类器，我们给他一个测试数据，让他来进行分类，在使用KNN之前，我们应该对测试数据有所了解，我们的数据应该是大小为数据数目
# 乘以特征数目的浮点数值，然后我们就可以通过计算找到测试数的最近邻居。我们可以设置返回的最近邻居的数目，返回值包括：
# 1 由KNN算法计算得到的测试数据的类别标志（0，1）如果您想要使用最近邻算法，只需要将k设为1，K就是最近邻的数目
# 2 k个最近邻居的类别标志
# 3 每个最近邻居到测试数据的距离
# 
# 让我们看看它是如何工作的，测试数据被标记为绿色
# =============================================================================

newcomer=np.random.randint(0,100,(1,2)).astype(np.float32)
plt.scatter(newcomer[:,0],newcomer[:,1],80,'g','o')

knn=cv2.ml.KNearest_create()
knn.train(trainData,cv2.ml.ROW_SAMPLE,responses)#应该根据传入数组的形式填cv2.ml.ROW_SAMPLE或者cv2.ml.COL_SAMPLE
ret,result,neighours,dist=knn.findNearest(newcomer,3)