# -*- coding: utf-8 -*-
"""
Created on Sat Apr 20 20:59:03 2019

@author: dell
"""
# =============================================================================
# 目标：
# 学习图像金字塔
# 使用图像创建一个新水果‘橘子苹果’
# 将要学习的函数：cv2.pyrUp() cv2.pyrDown()
# 原理：
# 一般情况下，我们要处理的是一副具有固定分辨率的图像，但有些情况下，我们需要对同一个图像
# 的不同分辨率的子图进行处理。比如我们要在一幅图中查找某个目标，比如脸，我们不知道目标在
# 图像中的尺寸大小，这种情况下，我们需要创建一组图像，这些图像是具有不同分辨率的原始图像，
# 我们把这组图像叫做 图像金字塔（简单来说，就是同一图像的不同分辨率的子图集合）。如果我们
# 把最大的图像放在底部，最小的放在顶部，看起来就像一座金字塔，故此得名
#     有两类图像金字塔：高斯金字塔和拉普拉斯金字塔
#     高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的（每次高斯卷积以后就降采样一次）
# ，顶部图像的每个像素值等于下一层图像的5个（为什么是5个）像素的高斯加权平均值。这样操作一次，
# 一个MxN的图像就变成了一个M/2xN/2的图像。所以这副图像的面积就变成原来图像面积的四分之一。这被
# 称为Octave。连续进行这样的操作，我们就会得到一个分辨率不段下降的图像金字塔。我们可以用函数
# cv2.pyrDown()和cv2.pyrUp()构建图像金字塔
#     cv2.pyrDown()从一个高分辨率大尺寸的图像向上构建一个金字塔（尺寸变小，分辨率降低）
# =============================================================================
#import cv2
#img=cv2.imread('123.jpg')
#lower_reso=cv2.pyrDown(img)
#lower_reso1=cv2.pyrDown(lower_reso)
#cv2.imshow('123',lower_reso1)
#up_reso1=cv2.pyrUp(lower_reso1)
#cv2.imshow('1234',up_reso1)   
#
#import cv2
#import numpy as np
#img=cv2.imread('jishu.png',0)
#img=cv2.GaussianBlur(img,(5,5),1.52)
#img1=cv2.GaussianBlur(img,(5,5),2.15)
#img_1=img1-img
#cv2.imshow('1_0',img_1) ##漂亮的残差（拉普拉斯）金字塔

#苹果橘子融合
有时间再做